{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/chapter-6-the-message-broker",
    "result": {"data":{"post":{"slug":"/chapter-6-the-message-broker","title":"Chapter 6. The Message Broker","date":"12.01.2022","tags":[{"name":"HaeramKim","slug":"haeram-kim"},{"name":"BuildYourOwnIoTPlatform","slug":"build-your-own-io-t-platform"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Chapter 6. The Message Broker\",\n  \"date\": \"2022-01-12\",\n  \"tags\": [\"HaeramKim\", \"BuildYourOwnIoTPlatform\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Pub-Sub Paradigm\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Publishing\"), \" is similar with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Sending\"), \". In other words, \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Publishing some data\"), \" means \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Sending some data\"), \". Thus, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Publisher\"), \" is same with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"sending client\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Subscribing\"), \" is similar with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Receiving\"), \". That is, \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Subscribing some data\"), \" has the same meaning with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Receiving some data\"), \". Thus, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Subscriber\"), \" is the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"client who receives some data\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This paradigm decouples Publisher with Subscriber and they\\u2019re connected by intermediate node, the Broker.\")), mdx(\"h3\", null, \"Advantages\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Not all clients for broker doesn\\u2019t have to connected to the broker.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Client synchronization is not mandatory\"), \". They can publish some data or be subscribed in asynchronized way.\")), mdx(\"hr\", null), mdx(\"h2\", null, \"MQTT\"), mdx(\"h3\", null, \"Client\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"All of the things that is connected to broker can be called \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"Client\")), \". That is, not only sensors and actuators, but also applications can be one of \\u2018em.\")), mdx(\"h3\", null, \"Broker\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"And \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Broker of MQTT integrates all the clients and helps their communication in a Pub-Sub paradigm\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Since broker is the key for overall communication, \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Broker must be reliable and easy to deploy, monitor and maintain\"), \".\")), mdx(\"h3\", null, \"QoS\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"The term \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"QoS\"), \" means \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"Quality of Service\")), \".\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"QoS 0\"), \": Packet will be arrived \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"at most once\"), \" - It\\u2019s possible that packet is lost while communication.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"QoS 1\"), \": Packet will be arrived \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"at least once\"), \" - So, it means that possibility for duplicated packet is present.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"QoS 2\"), \": Packet must be arrived \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"exactly once\"), \".\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This is kinda \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"reliability of communication\"), \", but the difference is that we can choose one of them.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In other words, when connectivity is reliable and miss rate is relatively low, QoS 0 is appropriate choice.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Similarly, when connectivity is unreliable and possibilities for packet loss is very high, choosing QoS 2 must be considered.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can think \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"QoS as a degree of importantness\"), \".\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When packet isn\\u2019t important and makes no side-effects if we misses it, then QoS 0 is better choice than others.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Contrary, when packet is very important and must not be missed, then QoS 2 must be considered.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"QoS 1 is the optimum choice because duplicated packet can be handled in receiver side.\")), mdx(\"h3\", null, \"Handling connection\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For client to publish & subscribe some data, they need to be stay connected to the broker. But when connection is breaked unintentionally, there is no way for broker to know that client is still alive. This is called \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Half-open Connection\"), \". To avoid this, kinda connection handling is required.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Keep Alive Period\"), \" is the maximum interval between two points that packet is sent by a client. In other words, when Keep Alive Period is 100 and last packet is sent at time 300, then next packet must be sent before the time 400.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If client don\\u2019t have any packet to send, then it must send \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"PINGREQ\"), \". Purpose for sending \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"PINGREQ\"), \" to broker is to notify the broker that client is still alive.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When Keep Alive Time is expired and client didn\\u2019t send a PINGREQ, Broker will think that there are some problems and shut the connection down. This is called \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Ungraceful disconnection\"), \". And when this happens, Broker will send a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"LWT(Last Will and Testament)\"), \" to all the subscribers.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"LWT(Last Will and Testament)\"), \" is a message that will be sent and to broker at the connection stage. Broker will saves this message and when one publisher goes to ungraceful disconnection state, this message will be sent to the all subscribers.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"But since broker is not for storing data, additional flag is needed to notify the broker to save that message. It\\u2019s called \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Retained Message\"), \". When message is arrived with \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Retained Message\"), \" flag, broker will saves that message until client wants to overwrite it. This message is saved with topic, so that broker knows what message should be overwrited, or be sent to the subscribers. \")))), mdx(\"h3\", null, \"WebSocket\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When communicating with applications, it\\u2019s hard to use HTTP because it runs on request-response model fundamentally. For bidirectional communication, we might have to use another protocol and WebSocket might be great.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Additionally, WebSocket runs with TCP, and that is what MQTT runs on too. So, using WebSocket is more easier way for us to build IoT Platform.\")), mdx(\"h3\", null, \"Pros & Cons\"), mdx(\"h4\", null, \"Pros\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lightweight: MQTT can runs on low-bandwidth, low-capacity of battery environment.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Bidirectional: Both client and broker initiates the communication.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Liveness / Event-driven: When application needs live monitoring or something like that, MQTT might be a great choice.\")), mdx(\"h4\", null, \"Cons\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When number of clients is increased, then communication rate will increased parabolically.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For example, when 2 clients are attached to broker, and all of the clients subscribes all of the topic, then when one client publishes data, two data tranfer will happen (Client1 -> Broker, Broker -> Client 2) and vice versa. So, total number of transfer is 4.\")))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Pub-Sub Paradigm Publishing  is similar with  Sending . In other words,  Publishing some data  means  Sending some data . Thus,  Publisher…","timeToRead":3,"banner":null}},"pageContext":{"slug":"/chapter-6-the-message-broker","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}